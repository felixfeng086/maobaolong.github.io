<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[saltstack-minion]]></title>
      <url>%2Fgithub_blog%2F2016%2F12%2F16%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fbigdata%2Fsaltstack-minion%2F</url>
      <content type="text"><![CDATA[salt命令列表saltsalt-apisalt-callsalt-cpsalt-keysalt-mastersalt-minionsalt-runsalt-sshsalt-unity 在minion上查看正在执行的任务，可以通过文件来查看ls /var/cache/salt/minion/procmaster的jobls /var/cache/salt/master/jobs/ master端的jobs，默认保存时间为24小时123root@salt-master:~# grep &quot;keep_jobs&quot; /etc/salt/master#keep_jobs: 24root@salt-master:~# 查看jobsalt-run jobs.active 查看历史jobsalt-run jobs.list_jobs | tail -n 16 查看某个任务的执行结果salt-run jobs.lookup_jid 20140625200258757661 某个结点执行命令salt ‘172.16.166.34’ cmd.run ‘ls ‘ 将本机的文件拷贝到 目标结点的/root/getIP.pysalt-cp ‘172.16.166.34’ ./getIP.py /root/getIP.py]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派接人体感应传感器]]></title>
      <url>%2Fgithub_blog%2F2016%2F12%2F15%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2F%E6%A0%91%E8%8E%93%E6%B4%BE%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A5%E4%BA%BA%E4%BD%93%E6%84%9F%E5%BA%94%E4%BC%A0%E6%84%9F%E5%99%A8%2F</url>
      <content type="text"><![CDATA[HC-SR501 感应模块简介 对照前面的参数以及电路图，找到下面的左右针脚正负极，中间的PIN为感应输出，感应到人体时，输出3.3V高电平，检测不到信号时输出0。同时还要求工作电压在4.5V-20V之间。恰好树莓派的P1编号中第2，4号PIN都是5V的电压，满足要求，所以这次我们要接5V的电压。 参数调节旋钮是用来扭动控制一些参数的。比如探测的延时时间，灵敏度等等。具体可以参看 HC -SR501的说明书。这里我们都使用默认值。 但是有一个关键的L H模式调节阀门要介绍一下，右上角有三个针脚，按照我实物照片，假定从上到下为123 。还有一个黄色的套接头，图中套接头接通了2 3号，代表了H模式，这个套接头是可以拔下来的，然后插到上面来，接通1 2号，代表了L模式。 L模式是不可重复触发，当探测到一次人体时，输出一次高电平，保持一段时间恢复低电平，在此期间如果还是检测到了人体也不再延长这个高电平的时间。等到低电平的封锁时间（前面默认是2.5S）过了以后才又开始检测。 H模式是可以重复触发，如果一直感应到人体时，会一直输出高电平，直到探测不到人体后保持小段时间然后恢复低电平。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[alluxio介绍与安装]]></title>
      <url>%2Fgithub_blog%2F2016%2F12%2F13%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fbigdata%2Falluxio%2F</url>
      <content type="text"><![CDATA[介绍 概念：是一个开源的基于内存的分布式存储系统，现在成为开源社区中成长最快的大数据开源项目之一。 公司简介 由项目的创建者李浩源以及来自UC Berkeley, Google, CMU, Palantir, Stanford, Yahoo等不同公司和学校的项目核心开发者组成。 完成750万 dollars 的A轮融资，由Andreessen Horowitz投资（硅谷最著名的VC之一，主要成员为网景公司创始人之一）。 作者：Mingche Su链接：https://zhuanlan.zhihu.com/p/20624086来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 术语 Amazon AWS ：亚马逊AWS 云服务-中国领先的可扩展云计算平台 Amazon S3 ：是一种在Internet 上的云存储服务。 要上传数据（照片、视频、文档等），请首先在一个AWS 区域中创建存储桶。 然后，您可以将任何数量的对象上传到该存储桶。 安装 解压 12$ tar -xzf alluxio-1.3.0-bin.tar.gz$ cd alluxio-1.3.0 生成配置文件 1./bin/alluxio bootstrapConf localhost 启动1./bin/alluxio format]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux下文件类型及表示颜色]]></title>
      <url>%2Fgithub_blog%2F2016%2F12%2F01%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Flinux%2FLinux%E4%B8%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%A1%A8%E7%A4%BA%E9%A2%9C%E8%89%B2%2F</url>
      <content type="text"><![CDATA[Linux下文件类型及表示颜色: 白色：普通文件 (用-表示) n 红色：压缩文件 n 蓝色：目录文件 (用d表示) n 青蓝色：链接文件 (用l表示) n 黄色：设备文件(/dev目录下)(用b或c表示) b表示的是物理设备;c表示的是字符终端设备. n 青绿色：可执行文件(/bin、/sbin目录下) n 粉红色：图片文件或是socket文件(用s表示) n 青黄色：管道文件 (用p表示) Linux下用字符表示的文件类型 -：普通文件 d：目录文件 l：链接文件 b：块设备文件 c：字符设备文件 p：管道文件 Linux文件系统配置文件 /proc—–内核提供的一个接口，主要用来存储系统统计信息; /etc/mtab——–随着/proc/mount的变化而变化，文件系统的安装和卸载都会在这个文件中反映出来; /etc/fstab——-列出当前系统在启动时自动安装的所有文件系统，也可以使用mount -a 这个命令来手动的安 装这个文件中列出的所有文件系统;另外也可以通过修改这个配置文件，使系统在启动时自动安装我们所需要 的其他的文件系统; /etc/mtools.conf———dos文件系统上的操作的配置文件 Linux系统管理配置文件 /etc/group———-列出有效的组名称以及组中的用户信息; /etc/passwd———帐号的密码文件; 帐号—-密码——用户号(UID)—–用户组号(GID)—-所属组—–用户主目录—用户所使用的shell类型 /etc/shadow——–包含加密后的帐号信息; /etc/shells——-包含系统的可以使用的shell的列表; /etc/motd———每日的信息，root管理员向系统中所有用户传达信息时使用 Linux系统命令配置文件 /etc/lilo.conf 包含系统的缺省引导命令行参数，还有启动时使用的不同映象。您在 LILO 引导提示的时候按 Tab 键就可以看到这个列表。 /etc/logrotate.conf 维护 /var/log 目录中的日志文件。 /etc/identd.conf identd是一个超级服务器，这个文件对于的是它的配置文件。 /etc/ld.so.conf “动态链接程序”(Dynamic Linker)的配置。 /etc/inittab 按年代来讲，这是 UNIX 中第一个配置文件。在一台 UNIX 机器打开之后启动的第一个程序是 init，它知道该启动什么，这是由于 inittab 的存在。在运行级别改变时，init 读取 inittab，然后控制主进程的启动 Linux主机配置文件 /etc/host.conf———告诉域名服务器如何查找主机名 /etc/hosts———网络中已发现的主机的名称列表，用于解析主机名 /etc/sysconfig/network 主机名和网关的信息 文件 Linux连网配置文件 /etc/gated.conf gated 的配置。只能被 gated 守护进程所使用。 /etc/networks 列举从机器所连接的网络可以访问的网络名和网络地址。通过路由命令使用。允许使用网络 名称。 /etc/protocols 列举当前可用的协议。 /etc/resolv.conf 在程序请求“解析”一个 IP 地址时告诉内核应该查询哪个名称服务器。 /etc/rpc 包含 RPC 指令/规则，这些指令/规则可以在 NFS 调用、远程文件系统安装等中使用。 /etc/exports 要导出的文件系统(NFS)和对它的权限。 /etc/services 将网络服务名转换为端口号/协议。由 inetd、telnet、tcpdump 和一些其它程序读取。有一些C访问例程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery中attr和prop的区别（转）]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F24%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fweb%2Fjquery%E4%B8%ADattr%E5%92%8Cprop%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[jquery中attr和prop的区别转自〖芈老头〗的技术空间在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。 关于它们两个的区别，网上的答案很多。这里谈谈我的心得，我的心得很简单： 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。 对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 上面的描述也许有点模糊，举几个例子就知道了。 这个例子里&lt;a&gt;元素的DOM属性有href、target和class，这些属性就是&lt;a&gt;元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。 1&lt;a href=&quot;#&quot; id=&quot;link1&quot; action=&quot;delete&quot;&gt;删除&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、id和action”，很明显，前两个是固有属性，而后面一个“action”属性是我们自己自定义上去的，&lt;a&gt;元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用attr方法。使用prop方法取值和设置属性值时，都会返回undefined值。 1&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_self&quot; class=&quot;btn&quot;&gt;百度&lt;/a&gt; 再举一个例子： 12&lt;input id=&quot;chk1&quot; type=&quot;checkbox&quot; /&gt;是否可见&lt;input id=&quot;chk2&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;是否可见 像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。 12$(&quot;#chk1&quot;).prop(&quot;checked&quot;) == false$(&quot;#chk2&quot;).prop(&quot;checked&quot;) == true 如果上面使用attr方法，则会出现： 12$(&quot;#chk1&quot;).attr(&quot;checked&quot;) == undefined$(&quot;#chk2&quot;).attr(&quot;checked&quot;) == &quot;checked&quot; 全文完。 以下是官方建议attr(),prop()的使用： Attribute/Property .attr() .prop() accesskey √ align √ async √ √ autofocus √ √ checked √ √ class √ contenteditable √ draggable √ href √ id √ label √ location ( i.e. window.location ) √ √ multiple √ √ readOnly √ √ rel √ selected √ √ src √ tabindex √ title √ type √ width ( if needed over .width() ) √ 转自myloveattribute和property都可以翻译为属性，为了以示区别，通常把这两个单词翻译为属性与特性。 1&lt;div id=&quot;test&quot;&gt;Click Here&lt;/div&gt; 上面这段HTML语句中有三个节点，分别是Element “div”、attribute “id”、Text “click here”，我们最常见的attribute正式指的attribute类型节点，在JavaScript有专门处理attribute的函数 .getAttribute(name) / setAttribute(name,value)。当然attribute不只是我们能够在HTML文档上看到的这几个，我们可以自定义attributed加到DOM节点中 123456&lt;div id=&quot;test&quot;&gt;123&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var t=document.getElementById(&apos;test&apos;); t.setAttribute(&apos;class&apos;,&apos;active&apos;); t.setAttribute(&apos;customizedAttr&apos;,&apos;customized&apos;); &lt;/script&gt; 这样可以div被修改为 1&lt;div id=&quot;test&quot; class=&quot;active&quot; customizedattr=&quot;customized&quot;&gt;123&lt;/div&gt; 通过方法 setAttribute设置的attribute最终都会反映到元素的attribute类型的节点中 property是DOM对象的字段，跟我们平常使用的一些对象一样，包含很多字段，这些字段就是property，取值或者设置值和普通字段一样通过”对象.字段“的方式。 看起来attribute和property应该没有什么关系才对，怎么会。。。attribute和property容易混倄是因为很多attribute节点还有一个相对应的property属性，比如上面div的”id“ attribute 同样可以用t.id取到（实际上绝大部分人都是这样获取的），通过property更改id后，用getAttibute获取的id是更新后的id。 12t.id=&apos;test1&apos;;console.log(t.getAttribute(&apos;id&apos;));//test1 同样我们也可以自定义property 1t.customizedProp=&apos;customized prop&apos;; ==区别== 于build-in属性，attribute和property共享数据，attribute更改了会对property造成影响，反之亦然，但是两者的自定义属性是独立的数据，即使name一样，也互不影响，看起来是下面这张图，但是IE6、7没有作区分，依然共享自定义属性数据 并不是所有的attribute与对应的property名字都一致，比如刚才使用的attribute 的class属性，使用property操作的时候应该是这样className 1&lt;input id=&quot;test3&quot; type=&quot;checkbox&quot;/&gt; 1234567891011var t=document.getElementById(&apos;test3&apos;); console.log(t.getAttribute(&apos;checked&apos;));//null console.log(t.checked);//false; t.setAttribute(&apos;checked&apos;,&apos;checked&apos;); console.log(t.getAttribute(&apos;checked&apos;));//checked console.log(t.checked);//true t.checked=false; console.log(t.getAttribute(&apos;checked&apos;));//checked console.log(t.checked);//false 对于一些和路径相关的属性，两者取得值也不尽相同，但是同样attribute取得是字面量，property取得是计算后的完整路径 1&lt;a id=&quot;test4&quot; href=&quot;#&quot;&gt;Click&lt;/a&gt; 123var t=document.getElementById(&apos;test4&apos;); console.log(t.getAttribute(&apos;href&apos;));//# console.log(t.href);//file:///C:/Users/bsun/Desktop/ss/anonymous.html# 关于浏览器（IE）造成的兼容性问题可以看看IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现 ==attr和prop==相信看完上面内容，大家就明白为什么jQuery要添加prop方法了，在jQuery API中也有专门解释Attributes VS. Properties在一些特殊的情况下，attributes和properties的区别非常大。在jQuery1.6之前，.attr()方法在获取一些attributes的时候使用了property值，这样会导致一些不一致的行为。在jQuery1.6中，.prop()方法提供了一中明确的获取property值得方式，这样.attr()方法仅返回attributes。 比如，selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, 和defaultSelected应该使用.prop()方法获取/设置值。 在jQuery1.6之前这些不属于attribute的property需要用.attr()方法获取。这几个并没有相应的attibute，只有property。 关于布尔类型 attributes，比如一个这样的HTML标签，它在JavaScript中变量名为elem 1&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; elem.checked true (Boolean) Will change with checkbox state $( elem ).prop( “checked” ) true (Boolean) Will change with checkbox state elem.getAttribute( “checked” ) “checked” (String) Initial state of the checkbox; does not change $( elem ).attr( “checked” ) (1.6) “checked” (String) Initial state of the checkbox; does not change $( elem ).attr( “checked” ) (1.6.1+) “checked” (String) Will change with checkbox state $( elem ).attr( “checked” ) (pre-1.6) true (Boolean) Changed with checkbox state 根据W3C forms specification，checked属性是一个布尔值，这就意味着只要checked属性在HTML中表现出来了，那么相应的property就应该是true，即使checked没有值，这点儿对其它布尔类型的属性一样适用。 然而关于checked 属性需要记住的最重要的一点是：它和checked property并不是一致的。实际上这个attribute和defaultChecked property一致，而且只应该用来设置checkbox的初始值。checked attribute并不随着checkedbox的状态而改变，但是checked property却跟着变。因此浏览器兼容的判断checkebox是否被选中应该使用property 123if ( elem.checked )if ( $( elem ).prop( &quot;checked&quot; ) )if ( $( elem ).is( &quot;:checked&quot; ) ) 这对其它一些类似于selected、value这样的动态attribute也适用。 在IE9之前版本中，如果property没有在DOM元素被移除之前删除，使用.prop()方法设置DOM元素property（简单类型除外：number、string、boolean）的值会导致内存泄露。为了安全的设置DOM对象的值，避免内存泄露，可以使用.data()方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss攻击]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fweb%2Fxss%E6%94%BB%E5%87%BB_%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB%2F</url>
      <content type="text"><![CDATA[xss攻击]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Flinux%2Flinux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[#linux 常用命令 * history |grep scp * tail -f log/UGDAP.log * 只显示文件名： ls -l | grep ^[^d] | awk ‘{print $8}’只显示文件夹名：ls -l |grep ^d | awk ‘{print $8}’ 或者是 ls -d */ 恢复rm删除的文件显示所删除的文件所在的分区df -T /home 用debugFS查找被删除文件的inode号sudo debugfsdebugfs&gt;open /dev/sda5debugfs&gt;ls -d /home/mbl/study尖括号中的是inode 恢复inodeextundelete ${dev_describer} –restore-inode ${inode} 如果知道被删除文件的完整的路径，直接恢复extundelete ${deb_describer} –restore-file ${path} shell脚本常用变量$0: shell或shell脚本的名字$*:以一对双引号给出参数列表$@:将各个参数分别加双引号返回$#:参数的个数$_:代表上一个命令的最后一个参数$$:代表所在命令的PID$!:代表最后执行的后台命令的PID$?:代表上一个命令执行后的退出状态 curl curl -x 172.22.91.78:80 http://172.16.172.95:19888/ws/v1/history/mapreduce/jobs/job_1470405196301_64273|python -m json.tool&gt;job_1470405196301_64273.json 显示当前版本cat /proc/versionuname -acat /etc/release 显示iphostname -iifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6 | awk ‘{print $2}’ | tr -d “addr:”ifconfig enp0s25|grep inet|grep -v 127.0.0.1|grep -v inet6 | awk ‘{print $2}’ | tr -d “addr:” 测试端口是否通telnet 172.22.91.34 8087 查看端口是否被占用netstat -tunlp |grep 80lsof -i 80 /bin/bash^M: 解释器错误: 没有那个文件或目录sed -i ‘s/\r$//‘ check_tool.sh 后台启动进程，重定向输出到文件nohup command &gt; myout.file 2&gt;&amp;1 &amp; 杀进程ps -ef | grep tomcat | awk ‘{print $2}’ | xargs kill -9或kill ps -ef | grep [j]enkins.war | awk &#39;{ print $2 }&#39;虽然提示没有找到进程pid，但已经杀掉了 开机自动挂载分区用blkid列出分区uuid和typesudo blkid接下来修改自动挂载的配置文件：sudo vim /etc/fstab增加一行UUID=11263962-9715-473f-9421-0b604e895aaa /data ext4 defaults 0 1 zip解压中文乱码ubuntu下 unzip -O CP936 xxx.zip -d exdir 权限home目录不能有其它用户写权限/root .ssh 只能是 700 linux权限777 rwxrwxrwx （所有者，本组用户，其它用户）rwx=读，写，执行 ssh-copy-id设置root密码sudo passwd root 在任务栏显示网速sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install indicator-netspeed 设置显示桌面快捷键sudo apt-get install compizconfig-settings-managerccsm KWPlayer 酷我音乐盒Iptux — 局域网聊天工具(飞鸽Linux版)sudo apt-get install iptux System Load Indicator ( 系统状态指示器）sudo add-apt-repository ppa:indicator-multiload/stable-dailysudo apt-get updatesudo apt-get install indicator-multiload XBMC（媒体中心）XBMC（媒体中心）sudo add-apt-repository ppa:team-xbmc/ppasudo apt-get updatesudo apt-get install xbmc VMware Workstation安装方法（包含下载、安装、激活、序列号）http://www.kashu.org/1024.html wiresharkhttp://ppa.launchpad.net/wireshark-dev/stable/ubuntu/pool/main/w/wireshark/ppa:wireshark-dev/stable .tar.gz 格式解压为 tar -zxvf xx.tar.gz.tar.bz2 格式解压为 tar -jxvf xx.tar.bz2 查看linux版本rpm -qa|grep kernel 中文Linux 常用的locale是zh_CN.gb2312，zh_CN.gbk，zh_CN.gb18030 和 zh_CN.UTF-8 。通过如下命令可以查询系统的locale：#echo $LANG fdisk -l mkdir /mnt/usbmount命令格式：mount [-参数] [设备名称] [挂载点] [其他参数]mount /dev/sdb1 /mnt/usbumount /dev/sdb1 改变用户组和用户123456789基本语法：chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录参数：-R : 进行递归( recursive )的持续更改，即连同子目录下的所有文件、目录都更新成为这个用户组。常常用在更改某一目录的情况。示例1：[root@localhost home]# touch testfile //由 root 用户创建文件[root@localhost home]# ls testfile –l 查看文件夹下容量du -ah –max-depth=1 配置ssh 超时空闲时间服务器配置:123/etc/profile 中的配置，增加一个参数TMOUT=6000 //100分钟，应该够用了echo &quot;TMOUT=6000 &quot; &gt;&gt;/etc/profilesource /etc/profile //立即生效 客户端配置:方法很简单，只需在客户端电脑上编辑（需要root权限）/etc/ssh/ssh_config，并添加如下一行：ServerAliveInterval 60 服务器端设置: 如果有相应的权限，也可以在服务器端设置，即编辑/etc/ssh/sshd_config，并添加：ClientAliveInterval 60 重启SSH服务器后该项设置会生效。每一个连接到此服务器上的客户端都会受其影响。应注意启用该功能后，安全性会有一定下降（比如忘记登出时……） Linux常见问题解答–如何修复”tar：由于前一个错误导致于失败状态中退出”Exiting with failure status due to previous errors去掉v，只看错误流 百度网盘公开链接wget下载wget -c –referer=公开链接地址 -O 输出文件名 “直接下载地址” ，其中-c表示断点续传wget -c –referer=http://pan.baidu.com/s/1pL0IUxH -O a.zip “http://61.179.228.93/d1.baidupcs.com/file/4b43140bd6212b333237b391961932a4?bkt=p3-0000eea78a1d47d0402b131c2736fe70a488&amp;xcode=c0a39d5fa7dcff84c1a1bca47e82ddfb123eeb8f4d2e9e54ded0b7c77404c736&amp;fid=50867796-250528-751846568268583&amp;time=1481855378&amp;sign=FDTAXGERLBH-DCb740ccc5511e5e8fedcff06b081203-mq8GWRwB7zY3FSpQOglOpVoSn8I%3D&amp;to=lc&amp;fm=Qin,B,U,nc&amp;sta_dx=137584648&amp;sta_cs=2496&amp;sta_ft=7z&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=Qingdao,B,U,nc&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=14005e8f94567db20cb9f1c95efbd7a8a7b7c50dcb1a000008336008&amp;sl=75956300&amp;expires=8h&amp;rt=sh&amp;r=739923821&amp;mlogid=8127629174281954396&amp;vuk=-&amp;vbdid=2201694974&amp;fin=FIFA.2002.Green.Edition-ALI213.7z&amp;fn=FIFA.2002.Green.Edition-ALI213.7z&amp;slt=pm&amp;uta=0&amp;rtype=1&amp;iv=0&amp;isw=0&amp;dp-logid=8127629174281954396&amp;dp-callid=0.1.1&amp;csl=600&amp;csign=RJ%2BYoZ6FqCL1OLeGHSbtuImu3ys%3D&amp;wshc_tag=0&amp;wsts_tag=58535192&amp;wsid_tag=6fccf309&amp;wsiphost=ipdbm“]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fair-scheduler]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fbigdata%2Fhadoop%2Fyarn%2Ffair-scheduler%2F</url>
      <content type="text"><![CDATA[fair-scheduler.xml的配置在一个公司内部的Hadoop Yarn集群，肯定会被多个业务、多个用户同时使用，共享Yarn的资源，如果不做资源的管理与规划，那么整个Yarn的资源很容易被某一个用户提交的Application占满，其它任务只能等待，这种当然很不合理，我们希望每个业务都有属于自己的特定资源来运行MapReduce任务，Hadoop中提供的公平调度器–Fair Scheduler，就可以满足这种需求。 Fair Scheduler将整个Yarn的可用资源划分成多个资源池，每个资源池中可以配置最小和最大的可用资源（内存和CPU）、最大可同时运行Application数量、权重、以及可以提交和管理Application的用户等。 根据用户名分配资源池 如图所示，假设整个Yarn集群的可用资源为100vCPU，100GB内存，现在为3个业务各自规划一个资源池，另外，规划一个default资源池，用于运行其他用户和业务提交的任务。如果没有在任务中指定资源池（通过参数mapreduce.job.queuename），那么可以配置使用用户名作为资源池名称来提交任务，即用户businessA提交的任务被分配到资源池businessA中，用户businessC提交的任务被分配到资源池businessC中。除了配置的固定用户，其他用户提交的任务将会被分配到资源池default中。 这里的用户名，就是提交Application所使用的Linux/Unix用户名。 另外，每个资源池可以配置允许提交任务的用户名，比如，在资源池businessA中配置了允许用户businessA和用户lxw1234提交任务，如果使用用户lxw1234提交任务，并且在任务中指定了资源池为businessA，那么也可以正常提交到资源池businessA中。 根据权重获得额外的空闲资源在每个资源池的配置项中，有个weight属性（默认为1），标记了资源池的权重，当资源池中有任务等待，并且集群中有空闲资源时候，每个资源池可以根据权重获得不同比例的集群空闲资源。 比如，资源池businessA和businessB的权重分别为2和1，这两个资源池中的资源都已经跑满了，并且还有任务在排队，此时集群中有30个Container的空闲资源，那么，businessA将会额外获得20个Container的资源，businessB会额外获得10个Container的资源。 最小资源保证在每个资源池中，允许配置该资源池的最小资源，这是为了防止把空闲资源共享出去还未回收的时候，该资源池有任务需要运行时候的资源保证。 比如，资源池businessA中配置了最小资源为（5vCPU，5GB），那么即使没有任务运行，Yarn也会为资源池businessA预留出最小资源，一旦有任务需要运行，而集群中已经没有其他空闲资源的时候，这个最小资源也可以保证资源池businessA中的任务可以先运行起来，随后再从集群中获取资源。 动态更新资源配额Fair Scheduler除了需要在yarn-site.xml文件中启用和配置之外，还需要一个XML文件来配置资源池以及配额，而该XML中每个资源池的配额可以动态更新，之后使用命令：yarn rmadmin –refreshQueues 来使得其生效即可，不用重启Yarn集群。 需要注意的是：动态更新只支持修改资源池配额，如果是新增或减少资源池，则需要重启Yarn集群。 1. 配置文件yarn-site.xml （1） yarn.scheduler.fair.allocation.file ：自定义XML配置文件所在位置，该文件主要用于描述各个队列的属性，比如资源量、权重等，具体配置格式将在后面介绍。 （2） yarn.scheduler.fair.user-as-default-queue：当应用程序未指定队列名时，是否指定用户名作为应用程序所在的队列名。如果设置为false或者未设置，所有未知队列的应用程序将被提交到default队列中，默认值为true。 （3） yarn.scheduler.fair.preemption：是否启用抢占机制，默认值是false。 （4） yarn.scheduler.fair.sizebasedweight：在一个队列内部分配资源时，默认情况下，采用公平轮询的方法将资源分配各各个应用程序，而该参数则提供了另外一种资源分配方式：按照应用程序资源需求数目分配资源，即需求资源数量越多，分配的资源越多。默认情况下，该参数值为false。 （5） yarn.scheduler.assignmultiple：是否启动批量分配功能。当一个节点出现大量资源时，可以一次分配完成，也可以多次分配完成。默认情况下，该参数值为false。 （6） yarn.scheduler.fair.max.assign：如果开启批量分配功能，可指定一次分配的container数目。默认情况下，该参数值为-1，表示不限制。 （7） yarn.scheduler.fair.locality.threshold.node：当应用程序请求某个节点上资源时，它可以接受的可跳过的最大资源调度机会。当按照分配策略，可将一个节点上的资源分配给某个应用程序时，如果该节点不是应用程序期望的节点，可选择跳过该分配机会暂时将资源分配给其他应用程序，直到出现满足该应用程序需的节点资源出现。通常而言，一次心跳代表一次调度机会，而该参数则表示跳过调度机会占节点总数的比例，默认情况下，该值为-1.0，表示不跳过任何调度机会。 （8） yarn.scheduler.fair.locality.threshold.rack：当应用程序请求某个机架上资源时，它可以接受的可跳过的最大资源调度机会。 （9） yarn.scheduler.increment-allocation-mb：内存规整化单位，默认是1024，这意味着，如果一个Container请求资源是1.5GB，则将被调度器规整化为ceiling(1.5 GB / 1GB) * 1G=2GB。 （10） yarn.scheduler.increment-allocation-vcores：虚拟CPU规整化单位，默认是1，含义与内存规整化单位类似。 2. 自定义配置文件 Fair Scheduler允许用户将队列信息专门放到一个配置文件（默认是fair-scheduler.xml），对于每个队列，管理员可配置以下几个选项： （1） minResources ：最少资源保证量，设置格式为“X mb, Y vcores”，当一个队列的最少资源保证量未满足时，它将优先于其他同级队列获得资源，对于不同的调度策略（后面会详细介绍），最少资源保证量的含义不同，对于fair策略，则只考虑内存资源，即如果一个队列使用的内存资源超过了它的最少资源量，则认为它已得到了满足；对于drf策略，则考虑主资源使用的资源量，即如果一个队列的主资源量超过它的最少资源量，则认为它已得到了满足。 （2） maxResources：最多可以使用的资源量，fair scheduler会保证每个队列使用的资源量不会超过该队列的最多可使用资源量。 （3） maxRunningApps：最多同时运行的应用程序数目。通过限制该数目，可防止超量Map Task同时运行时产生的中间输出结果撑爆磁盘。 （4） minSharePreemptionTimeout：最小共享量抢占时间。如果一个资源池在该时间内使用的资源量一直低于最小资源量，则开始抢占资源。 （5） schedulingMode/schedulingPolicy：队列采用的调度模式，可以是fifo、fair或者drf。 （6） aclSubmitApps：可向队列中提交应用程序的Linux用户或用户组列表，默认情况下为“*”，表示任何用户均可以向该队列提交应用程序。需要注意的是，该属性具有继承性，即子队列的列表会继承父队列的列表。配置该属性时，用户之间或用户组之间用“，”分割，用户和用户组之间用空格分割，比如“user1, user2 group1,group2”。 （7） aclAdministerApps：该队列的管理员列表。一个队列的管理员可管理该队列中的资源和应用程序，比如可杀死任意应用程序。 管理员也可为单个用户添加maxRunningJobs属性限制其最多同时运行的应用程序数目。此外，管理员也可通过以下参数设置以上属性的默认值： （1） userMaxJobsDefault：用户的maxRunningJobs属性的默认值。 （2） defaultMinSharePreemptionTimeout ：队列的minSharePreemptionTimeout属性的默认值。 （3） defaultPoolSchedulingMode：队列的schedulingMode属性的默认值。 （4） fairSharePreemptionTimeout：公平共享量抢占时间。如果一个资源池在该时间内使用资源量一直低于公平共享量的一半，则开始抢占资源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hadoop_rest]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fbigdata%2Fhadoop%2Fhadoop_rest%2F</url>
      <content type="text"><![CDATA[curl -x 172.22.91.78:80 -X GET -H “Accept:application/xml” http://172.16.172.95:19888/ws/v1/history/mapreduce/jobs/job_1470405196301_64396 curl -x 172.22.91.78:80 -X GET -H “Accept:application/json” http://172.16.172.95:19888/ws/v1/history/mapreduce/jobs/job_1470405196301_64396|python -m json.tool]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shell脚本]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Flinux%2Fshell%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[cd dirname $0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hadoop 命令]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fbigdata%2Fhadoop%2Fhadoop%2F</url>
      <content type="text"><![CDATA[显示loghadoop fs -cat /tmp/app-logs/prestotest/logs/application_1460457323828_0044/BJHC-Client-77104.hadoop.jd.local_50086 创建文件夹hadoop fs -mkdir /user/admin/aaron/newDir 上传文件hadoop fs –put /home/admin/newFile /user/admin/aaron/ 下载文件hadoop fs –get /user/admin/aaron/newFile /home/admin/newFile 显示所有jobhadoop job -list]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[playframework]]></title>
      <url>%2Fgithub_blog%2F2016%2F11%2F09%2F%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%2Fweb%2Fplayframework%2F</url>
      <content type="text"><![CDATA[目录结构123456789101112131415161718192021222324252627282930313233343536373839web_app 根目录 | sbt SBT Unix 批处理脚本用于启动sbt-launch.jar | sbt.bat SBT Windows 批处理脚本用于启动sbt-launch.jar | sbt-launch.jar SBT 启动的Java可执行类库|+---app Play Web 应用全部代码所在目录| || +---models 模型代码所在目录| | Message.scala 留言板例程模型代码| || +---controllers 控制器代码所在目录| | Application.scala 默认控制器代码| || \---views 视图（Play Scala HTML模板） 代码所在目录| main.scala.html 主模板文件| index.scala.html 首页模板文件| msgboard.scala.html 留言板例程模板文件|+---conf Play 配置文件所在目录| application.conf 应用配置文件| routes 应用入口路由文件，所有的HTTP请求将通过该文件转发到指定的Scala对象处理|+---logs 日志目录| application.log 应用运行日志|+---project SBT工程文件| build.properties 保存所需的SBT版本信息，通常无需更改| Build.scala 主要的工程配置文件| plugins.sbt 告知SBT本工程所需要的插件以及下载位置|+---public 存储一切直接发送给浏览器的资源文件| || +---images 图像文件，如JPEG、PNG、GIF等| || +---javascripts JavaScript脚本文件| || \---stylesheets CSS样式表文件|\---target 存放编译后的可执行代码和编译时的中间代码 执行play,进入play命令行后，执行:idea with-sources=yes 或者 eclipse with-source=true.生成对应的工程文件，之后，可以用eclipse或idea导入工程；]]></content>
    </entry>

    
  
  
</search>
